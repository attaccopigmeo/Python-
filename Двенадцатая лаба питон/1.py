"""
Дано натуральное N и массив целых чисел размерности N. Отсортировать данный массив
по возрастанию методом простых обменов. В процессе сортировки отсортированную часть
накапливать в конце массива. Вывести содержимое массива после каждой итерации сортировки.
Одной итерацией сортировки считать такое действие, в результате которого один элемент
массива гарантированно встает на правильное место в отсортированном массиве. При выводе
массива отсортированную часть отделать от неотсортированной с помощью символа |. Протокол
сортировки выводить в текстовый файл.
"""
# НЕВЕРНО сдвигается граница (должна идти лесенкой)
# Одной итерацией сортировки считать такое действие, в результате которого один элемент//
# массива гарантированно встает на правильное место в отсортированном массиве
import numpy as np


N = int(input("Введите длину массива: "))
array = np.random.randint(0, 100, (N)) #Задаем массив и заполняем его через random
f = open("/Users/kamillasmidt/Python--2/Двенадцатая лаба питон/sort1.txt", "w")
print("Сгенерированный массив:", *array, file = f)
is_sorted = False #Флаг, необходимый для сортировки
"""Bubble sort is a sorting by simple exchange"""
while not is_sorted: #Пока массив не отсортирован
    is_sorted = True #Сначала предполагаем массив отсортированным
    for j in range(N - 2, - 1, - 1): #Сортировка с конца
        if array[j] > array[j + 1]: #Нашли неправильный порядок
            is_sorted = False #Значит массив не отсорт. нужно будет пройтись еще раз
            array[j], array[j + 1] = array[j + 1], array[j] #Восст. правильный порядок
            # При выводе определяем отсорт. часть и отделяем неотсорт. часть
    i = N
    for k in range(N - 1):
        if array[k] <= array[k + 1]:
            i = k + 1 #Если массив отсорт., обновляем индекс начала отсорт. части
        else:
            break
    print("Итог итерации:", *(array[:i]), "|", *(array[i:]), file = f)
